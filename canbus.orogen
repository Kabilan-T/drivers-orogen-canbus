name "canbus"

using_library "canbus"
import_types_from "base"
import_types_from "canmessage.hh"
import_types_from "canTypes.hh"

task_context "Task" do
    fd_driven
    needs_configuration

    property("device", "/std/string").
        doc "the device file used to connect to the CAN bus"

    property("deviceType", "/canbus/DRIVER_TYPE").
        doc "the device type, this determines which driver will be used to open the device"

    property("checkBusOkCount", "int").
        doc "check after how many calls of the update hook the CAN bus will be checked, if it is still ok"

    output_port("stats", "/canbus/Statistics").
        doc "some statistics about the CAN bus"

    input_port("in", "/canbus/Message").
        doc "ports for writing CAN messages on the bus"

    dynamic_output_port(/\w+/, "/canbus/Message").
        doc "port for reading CAN messages from the bus"

    operation("watch").
        returns("bool").
        argument("name", "/std/string", "the name of the device to watch. The corresponding output port will have this name").
        argument("id", "int", "the bitset representing the associated CAN IDs").
        argument("mask", "int", "a mask on the 'id' parameter")

    operation("unwatch").
        returns("bool").
        argument("name", "/std/string", "the name of the watched device to remove")

    port_driven
    exception_states :IO_ERROR
end

using_task_library "logger"
deployment "test" do
    do_not_install
    t = task("can", "canbus::Task")

    add_default_logger

    if !corba_enabled?
        browse t
    end
end

